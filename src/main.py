"""
Aplikace pro stahov√°n√≠ nahr√°vek hovor≈Ø ze Spinoco API na SharePoint.

Implementuje ofici√°ln√≠ Spinoco Call and Chat Transcription and Synchronisation API
pro stahov√°n√≠ nahr√°vek za √∫ƒçelem tr√©nov√°n√≠ chatbota.

Workflow:
1. St√°hni v≈°echny dokonƒçen√© hovory s nahr√°vkami
2. St√°hni nahr√°vky (.ogg) na SharePoint do slo≈æek podle mƒõs√≠ce  
3. Zkontroluj velikosti soubor≈Ø
4. Sma≈æ √∫spƒõ≈°nƒõ sta≈æen√© nahr√°vky ze Spinoco
5. Zaloguj v√Ωsledky a ukonƒçi se
"""

import asyncio
import sys
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Any
import structlog

from .config import settings
from .logger import setup_logging
from .spinoco_client import SpinocoClient, CallTask, CallRecording
from .sharepoint_client import SharePointClient


class SpinocoRecordingDownloader:
    """
    Jednoduch√° aplikace pro batch stahov√°n√≠ nahr√°vek ze Spinoco.
    
    St√°hne v≈°echny dostupn√© nahr√°vky, nahraje na SharePoint,
    zkontroluje velikosti a sma≈æe ze Spinoco.
    """
    
    def __init__(self):
        self.logger = setup_logging(
            log_level=settings.log_level,
            log_file="spinoco_download.log",
            enable_colors=True
        )
        
        # Jednoduch√© statistiky
        self.stats = {
            "calls_found": 0,
            "recordings_found": 0,
            "recordings_downloaded": 0,
            "recordings_deleted": 0,
            "errors": 0,
            "start_time": datetime.now()
        }
    
    async def run(self):
        """Hlavn√≠ metoda aplikace."""
        try:
            self.logger.info("üöÄ Spou≈°t√≠m Spinoco Recording Downloader")
            
            # Vytvo≈ô klienty
            async with SpinocoClient(
                api_token=settings.spinoco_api_key,
                base_url=settings.spinoco_base_url
            ) as spinoco_client:
                
                # Vytvo≈ô SharePoint klient s OAuth2 (jen pokud nen√≠ test re≈æim)
                if settings.test_mode:
                    # Test re≈æim - bez SharePoint
                    self.logger.info("üß™ Test re≈æim - stahov√°n√≠ na lok√°ln√≠ disk")
                    await self.process_all_recordings(spinoco_client, None)
                else:
                    # Produkƒçn√≠ re≈æim - s SharePoint
                    if settings.use_oauth2():
                        sharepoint_client = SharePointClient(
                            site_url=settings.sharepoint_site_url,
                            client_id=settings.sharepoint_client_id,
                            client_secret=settings.sharepoint_client_secret,
                            tenant_id=settings.sharepoint_tenant_id,
                            folder_path=settings.sharepoint_folder_path
                        )
                    else:
                        sharepoint_client = SharePointClient(
                            site_url=settings.sharepoint_site_url,
                            username=settings.sharepoint_username,
                            password=settings.sharepoint_password,
                            folder_path=settings.sharepoint_folder_path
                        )
                    
                    async with sharepoint_client:
                        self.logger.info("‚úÖ Klienti √∫spƒõ≈°nƒõ inicializov√°ni")
                        await self.process_all_recordings(spinoco_client, sharepoint_client)
                
                # V√Ωsledn√© statistiky
                self.log_final_stats()
                
        except KeyboardInterrupt:
            self.logger.info("‚èπÔ∏è Stahov√°n√≠ p≈ôeru≈°eno u≈æivatelem")
        except Exception as e:
            self.logger.error("‚ùå Kritick√° chyba aplikace", error=str(e))
            self.stats["errors"] += 1
            raise
    
    async def process_all_recordings(self, spinoco_client: SpinocoClient, sharepoint_client: SharePointClient):
        """
        Hlavn√≠ batch processing logika.
        
        1. Z√≠skej v≈°echny dokonƒçen√© hovory s nahr√°vkami
        2. St√°hni v≈°echny nahr√°vky na SharePoint
        3. Zkontroluj velikosti
        4. Sma≈æ √∫spƒõ≈°n√© ze Spinoco
        """
        self.logger.info("üìû Z√≠sk√°v√°m v≈°echny dokonƒçen√© hovory s nahr√°vkami")
        
        # Krok 1: Z√≠skej v≈°echny hovory s nahr√°vkami
        calls_with_recordings = []
        async for call in spinoco_client.get_completed_calls_with_recordings():
            calls_with_recordings.append(call)
            self.stats["calls_found"] += 1
            
            # Spoƒç√≠tej nahr√°vky
            recordings = spinoco_client.extract_available_recordings(call)
            self.stats["recordings_found"] += len(recordings)
        
        self.logger.info(
            f"üîç Nalezeno {self.stats['calls_found']} hovor≈Ø "
            f"s {self.stats['recordings_found']} nahr√°vkami"
        )
        
        if not calls_with_recordings:
            self.logger.info("‚úÖ ≈Ω√°dn√© nov√© nahr√°vky k sta≈æen√≠")
            return
        
        # Krok 2: St√°hni nahr√°vky (SharePoint nebo lok√°lnƒõ podle test_mode)
        download_results = []
        semaphore = asyncio.Semaphore(settings.max_concurrent_downloads)
        
        download_tasks = []
        recording_count = 0
        
        for call in calls_with_recordings:
            recordings = spinoco_client.extract_available_recordings(call)
            for recording in recordings:
                # Omez poƒçet v test re≈æimu
                if settings.test_mode and recording_count >= settings.max_test_recordings:
                    self.logger.info(f"üß™ Test re≈æim - omezeno na {settings.max_test_recordings} nahr√°vek")
                    break
                
                if settings.test_mode:
                    task = self.download_single_recording_local(
                        call, recording, spinoco_client, semaphore
                    )
                else:
                    task = self.download_single_recording(
                        call, recording, spinoco_client, sharepoint_client, semaphore
                    )
                download_tasks.append(task)
                recording_count += 1
            
            if settings.test_mode and recording_count >= settings.max_test_recordings:
                break
        
        # Spus≈• paralelnƒõ
        self.logger.info(f"‚¨áÔ∏è Stahuji {len(download_tasks)} nahr√°vek paralelnƒõ")
        download_results = await asyncio.gather(*download_tasks, return_exceptions=True)
        
        # Krok 3: Zpracuj v√Ωsledky a sma≈æ √∫spƒõ≈°n√© ze Spinoco
        successful_deletions = []
        for i, result in enumerate(download_results):
            if isinstance(result, Exception):
                self.logger.error(f"‚ùå Chyba p≈ôi stahov√°n√≠: {result}")
                self.stats["errors"] += 1
            else:
                call, recording, success = result
                if success:
                    self.stats["recordings_downloaded"] += 1
                    successful_deletions.append((call, recording))
                else:
                    self.stats["errors"] += 1
        
        # Krok 4: Sma≈æ √∫spƒõ≈°nƒõ sta≈æen√© nahr√°vky ze Spinoco (jen v produkci)
        if successful_deletions and not settings.test_mode:
            self.logger.info(f"üóëÔ∏è Ma≈æu {len(successful_deletions)} nahr√°vek ze Spinoco")
            await self.delete_recordings_from_spinoco(
                successful_deletions, spinoco_client
            )
        elif settings.test_mode:
            self.logger.info(f"üß™ Test re≈æim - NEMAZ√ÅM ze Spinoco ({len(successful_deletions)} nahr√°vek)")
        
        self.logger.info("‚úÖ Batch processing dokonƒçen")
    
    async def download_single_recording(
        self,
        call: CallTask,
        recording: CallRecording,
        spinoco_client: SpinocoClient,
        sharepoint_client: SharePointClient,
        semaphore: asyncio.Semaphore
    ) -> tuple[CallTask, CallRecording, bool]:
        """
        St√°hne jednu nahr√°vku ze Spinoco na SharePoint a zkontroluje velikost.
        
        Returns:
            tuple: (call, recording, success)
        """
        async with semaphore:
            try:
                # Vygeneruj n√°zev souboru podle metadat (max 15 slov)
                filename = self.generate_filename_from_metadata(call, recording)
                
                # V≈°echno do jedn√© slo≈æky (bez podslo≈æek)
                folder_path = settings.sharepoint_folder_path
                
                self.logger.info(
                    f"‚¨áÔ∏è Stahuji nahr√°vku {recording.id}",
                    call_id=call.id,
                    filename=filename,
                    folder=folder_path
                )
                
                # St√°hni nahr√°vku ze Spinoco
                recording_data = await spinoco_client.download_recording(call.id, recording.id)
                original_size = len(recording_data)
                
                # Nahraj na SharePoint
                file_info = await sharepoint_client.upload_file(
                    file_content=recording_data,
                    filename=filename,
                    folder_path=folder_path,
                    overwrite=False
                )
                
                # Zkontroluj velikost
                uploaded_size = file_info.get("size", 0)
                if uploaded_size != original_size:
                    self.logger.error(
                        f"‚ùå Velikost se neshoduje: {original_size} != {uploaded_size}",
                        filename=filename
                    )
                    return call, recording, False
                
                self.logger.info(
                    f"‚úÖ Nahr√°vka √∫spƒõ≈°nƒõ nahr√°na a zkontrolov√°na",
                    filename=filename,
                    size_mb=round(original_size / 1024 / 1024, 2)
                )
                
                return call, recording, True
                
            except Exception as e:
                self.logger.error(
                    f"‚ùå Chyba p≈ôi stahov√°n√≠ nahr√°vky",
                    call_id=call.id,
                    recording_id=recording.id,
                    error=str(e)
                )
                return call, recording, False
    
    async def download_single_recording_local(
        self,
        call: CallTask,
        recording: CallRecording,
        spinoco_client: SpinocoClient,
        semaphore: asyncio.Semaphore
    ) -> tuple[CallTask, CallRecording, bool]:
        """
        St√°hne nahr√°vku ze Spinoco na lok√°ln√≠ disk (test re≈æim).
        
        Returns:
            tuple: (call, recording, success)
        """
        async with semaphore:
            try:
                # Vygeneruj n√°zev souboru
                filename = self.generate_filename_from_metadata(call, recording)
                
                # V≈°echno do jedn√© slo≈æky (bez podslo≈æek)
                local_path = Path(settings.local_download_path) / filename
                local_path.parent.mkdir(parents=True, exist_ok=True)
                
                self.logger.info(
                    f"‚¨áÔ∏è Stahuji nahr√°vku {recording.id} (TEST - lok√°lnƒõ)",
                    call_id=call.id,
                    filename=filename,
                    local_path=str(local_path)
                )
                
                # St√°hni nahr√°vku ze Spinoco
                recording_data = await spinoco_client.download_recording(call.id, recording.id)
                original_size = len(recording_data)
                
                # Ulo≈æ na disk
                local_path.write_bytes(recording_data)
                
                # Zkontroluj velikost
                saved_size = local_path.stat().st_size
                if saved_size != original_size:
                    self.logger.error(
                        f"‚ùå Velikost se neshoduje: {original_size} != {saved_size}",
                        filename=filename
                    )
                    return call, recording, False
                
                self.logger.info(
                    f"‚úÖ Nahr√°vka √∫spƒõ≈°nƒõ ulo≈æena lok√°lnƒõ",
                    filename=filename,
                    size_mb=round(original_size / 1024 / 1024, 2),
                    path=str(local_path)
                )
                
                return call, recording, True
                
            except Exception as e:
                self.logger.error(
                    f"‚ùå Chyba p≈ôi lok√°ln√≠m stahov√°n√≠",
                    call_id=call.id,
                    recording_id=recording.id,
                    error=str(e)
                )
                return call, recording, False
    
    def get_month_folder_local(self, call: CallTask) -> str:
        """Vr√°t√≠ slo≈æku podle mƒõs√≠ce pro lok√°ln√≠ ukl√°d√°n√≠."""
        try:
            call_time = datetime.fromtimestamp(call.lastUpdate / 1000)
            return f"{call_time.strftime('%Y')}/{call_time.strftime('%m')}"
        except Exception:
            return "unknown"
    
    async def delete_recordings_from_spinoco(
        self,
        successful_deletions: List[tuple[CallTask, CallRecording]],
        spinoco_client: SpinocoClient
    ):
        """Sma≈æe √∫spƒõ≈°nƒõ sta≈æen√© nahr√°vky ze Spinoco."""
        
        delete_tasks = []
        for call, recording in successful_deletions:
            delete_task = spinoco_client.delete_recording(call.id, recording.id)
            delete_tasks.append(delete_task)
        
        # Sma≈æ paralelnƒõ
        delete_results = await asyncio.gather(*delete_tasks, return_exceptions=True)
        
        # Zpracuj v√Ωsledky
        for i, result in enumerate(delete_results):
            call, recording = successful_deletions[i]
            if isinstance(result, Exception):
                self.logger.error(
                    f"‚ùå Nepoda≈ôilo se smazat nahr√°vku ze Spinoco",
                    call_id=call.id,
                    recording_id=recording.id,
                    error=str(result)
                )
                self.stats["errors"] += 1
            else:
                self.stats["recordings_deleted"] += 1
                self.logger.debug(
                    f"üóëÔ∏è Nahr√°vka smaz√°na ze Spinoco",
                    call_id=call.id,
                    recording_id=recording.id
                )
    
    def generate_filename_from_metadata(self, call: CallTask, recording: CallRecording) -> str:
        """
        Vygeneruje n√°zev souboru z metadat hovoru.
        
        Form√°t: YYYYMMDD_HHMMSS_caller_firstdigit_duration_recordingid.ogg
        """
        try:
            # Datum z lastUpdate
            call_time = datetime.fromtimestamp(call.lastUpdate / 1000)
            date_str = call_time.strftime("%Y%m%d_%H%M%S")
            
            # Telefonn√≠ ƒç√≠sla
            caller, callee = self.extract_phone_numbers(call)
            caller_full = caller.lstrip('+') if caller else "unknown"
            callee_first = callee.lstrip('+')[0] if callee else "0"
            
            # D√©lka hovoru
            duration_min = recording.duration // 1000 // 60
            duration_sec = (recording.duration // 1000) % 60
            duration_str = f"{duration_min}min{duration_sec}s"
            
            # Recording ID (zkr√°cen√©)
            recording_short = recording.id[:8]
            
            # Sestavit n√°zev
            filename = f"{date_str}_{caller_full}_{callee_first}_{duration_str}_{recording_short}.ogg"
            
            return filename
            
        except Exception as e:
            self.logger.warning(f"Chyba p≈ôi generov√°n√≠ n√°zvu souboru: {e}")
            # Fallback
            call_time = datetime.fromtimestamp(call.lastUpdate / 1000)
            date_str = call_time.strftime("%Y%m%d_%H%M%S")
            return f"{date_str}_{recording.id[:8]}.ogg"
    
    def get_month_folder_path(self, call: CallTask) -> str:
        """Vr√°t√≠ cestu ke slo≈æce podle mƒõs√≠ce z lastUpdate."""
        try:
            call_time = datetime.fromtimestamp(call.lastUpdate / 1000)
            month_folder = call_time.strftime("%Y/%m")
            
            # Kombinuj s base folder path
            if settings.sharepoint_folder_path:
                return f"{settings.sharepoint_folder_path.strip('/')}/{month_folder}"
            else:
                return month_folder
                
        except Exception as e:
            self.logger.warning(f"Chyba p≈ôi urƒçov√°n√≠ slo≈æky: {e}")
            return settings.sharepoint_folder_path or "recordings"
    
    def extract_phone_numbers(self, call: CallTask) -> tuple[str, str]:
        """Extrahuje telefonn√≠ ƒç√≠sla z call task."""
        try:
            direction = call.tpe.get("direction", {})
            direction_type = direction.get("__tpe")
            
            if direction_type == "Terminating":
                # P≈ô√≠choz√≠ hovor
                caller = direction.get("from", {}).get("number", {}).get("e164", "")
                callee = direction.get("toPhoneNumber", "")
            elif direction_type == "Originating":
                # Odchoz√≠ hovor
                caller = direction.get("fromPhoneNumber", "")
                callee = direction.get("to", {}).get("number", {}).get("e164", "")
            else:
                return "", ""
            
            return caller.lstrip('+'), callee.lstrip('+')
            
        except Exception:
            return "", ""
    
    def log_final_stats(self):
        """Vyp√≠≈°e fin√°ln√≠ statistiky."""
        duration = datetime.now() - self.stats["start_time"]
        
        self.logger.info(
            "üìä Fin√°ln√≠ statistiky stahov√°n√≠",
            duration=str(duration),
            calls_found=self.stats["calls_found"],
            recordings_found=self.stats["recordings_found"],
            recordings_downloaded=self.stats["recordings_downloaded"],
            recordings_deleted=self.stats["recordings_deleted"],
            errors=self.stats["errors"]
        )
        
        if self.stats["errors"] > 0:
            self.logger.warning(f"‚ö†Ô∏è Dokonƒçeno s {self.stats['errors']} chybami")
        else:
            self.logger.info("üéâ V≈°echny nahr√°vky √∫spƒõ≈°nƒõ zpracov√°ny!")


async def main():
    """Hlavn√≠ entry point aplikace."""
    try:
        downloader = SpinocoRecordingDownloader()
        await downloader.run()
        return 0
    except Exception as e:
        print(f"‚ùå Kritick√° chyba: {e}")
        return 1


if __name__ == "__main__":
    sys.exit(asyncio.run(main()))
