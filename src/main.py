"""
Aplikace pro stahov√°n√≠ nahr√°vek hovor≈Ø ze Spinoco API na SharePoint.

Implementuje ofici√°ln√≠ Spinoco Call and Chat Transcription and Synchronisation API
pro stahov√°n√≠ nahr√°vek za √∫ƒçelem tr√©nov√°n√≠ chatbota.

Workflow:
1. St√°hni v≈°echny dokonƒçen√© hovory s nahr√°vkami
2. St√°hni nahr√°vky (.ogg) na SharePoint do slo≈æek podle mƒõs√≠ce  
3. Zkontroluj velikosti soubor≈Ø
4. Sma≈æ √∫spƒõ≈°nƒõ sta≈æen√© nahr√°vky ze Spinoco
5. Zaloguj v√Ωsledky a ukonƒçi se
"""

import asyncio
import sys
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Any
import structlog

from .config import settings
from .logger import setup_logging
from .spinoco_client import SpinocoClient, CallTask, CallRecording
from .sharepoint_client import SharePointClient


class SpinocoRecordingDownloader:
    """
    Jednoduch√° aplikace pro batch stahov√°n√≠ nahr√°vek ze Spinoco.
    
    St√°hne v≈°echny dostupn√© nahr√°vky, nahraje na SharePoint,
    zkontroluje velikosti a sma≈æe ze Spinoco.
    """
    
    def __init__(self):
        self.logger = setup_logging(
            log_level=settings.log_level,
            log_file="spinoco_download.log",
            enable_colors=True
        )
        
        # Jednoduch√© statistiky
        self.stats = {
            "calls_found": 0,
            "recordings_found": 0,
            "recordings_downloaded": 0,
            "recordings_deleted": 0,
            "errors": 0,
            "start_time": datetime.now()
        }
    
    async def run(self):
        """Hlavn√≠ metoda aplikace."""
        try:
            self.logger.info("üöÄ Spou≈°t√≠m Spinoco Recording Downloader")
            
            # Vytvo≈ô klienty
            async with SpinocoClient(
                api_token=settings.spinoco_api_key,
                base_url=settings.spinoco_base_url
            ) as spinoco_client:
    
    # Vytvo≈ô SharePoint klient s OAuth2
    if settings.use_oauth2():
        sharepoint_client = SharePointClient(
            site_url=settings.sharepoint_site_url,
            client_id=settings.sharepoint_client_id,
            client_secret=settings.sharepoint_client_secret,
            tenant_id=settings.sharepoint_tenant_id,
            folder_path=settings.sharepoint_folder_path
        )
    else:
        sharepoint_client = SharePointClient(
            site_url=settings.sharepoint_site_url,
            username=settings.sharepoint_username,
            password=settings.sharepoint_password,
            folder_path=settings.sharepoint_folder_path
        )
    
    async with sharepoint_client:
                
                self.logger.info("‚úÖ Klienti √∫spƒõ≈°nƒõ inicializov√°ni")
                
                # Spus≈• batch processing
                await self.process_all_recordings(spinoco_client, sharepoint_client)
                
                # V√Ωsledn√© statistiky
                self.log_final_stats()
                
        except KeyboardInterrupt:
            self.logger.info("‚èπÔ∏è Stahov√°n√≠ p≈ôeru≈°eno u≈æivatelem")
        except Exception as e:
            self.logger.error("‚ùå Kritick√° chyba aplikace", error=str(e))
            self.stats["errors"] += 1
            raise
    
    async def process_all_recordings(self, spinoco_client: SpinocoClient, sharepoint_client: SharePointClient):
        """
        Hlavn√≠ batch processing logika.
        
        1. Z√≠skej v≈°echny dokonƒçen√© hovory s nahr√°vkami
        2. St√°hni v≈°echny nahr√°vky na SharePoint
        3. Zkontroluj velikosti
        4. Sma≈æ √∫spƒõ≈°n√© ze Spinoco
        """
        self.logger.info("üìû Z√≠sk√°v√°m v≈°echny dokonƒçen√© hovory s nahr√°vkami")
        
        # Krok 1: Z√≠skej v≈°echny hovory s nahr√°vkami
        calls_with_recordings = []
        async for call in spinoco_client.get_completed_calls_with_recordings():
            calls_with_recordings.append(call)
            self.stats["calls_found"] += 1
            
            # Spoƒç√≠tej nahr√°vky
            recordings = spinoco_client.extract_available_recordings(call)
            self.stats["recordings_found"] += len(recordings)
        
        self.logger.info(
            f"üîç Nalezeno {self.stats['calls_found']} hovor≈Ø "
            f"s {self.stats['recordings_found']} nahr√°vkami"
        )
        
        if not calls_with_recordings:
            self.logger.info("‚úÖ ≈Ω√°dn√© nov√© nahr√°vky k sta≈æen√≠")
            return
        
        # Krok 2: St√°hni v≈°echny nahr√°vky na SharePoint
        download_results = []
        semaphore = asyncio.Semaphore(settings.max_concurrent_downloads)
        
        download_tasks = []
        for call in calls_with_recordings:
            recordings = spinoco_client.extract_available_recordings(call)
            for recording in recordings:
                task = self.download_single_recording(
                    call, recording, spinoco_client, sharepoint_client, semaphore
                )
                download_tasks.append(task)
        
        # Spus≈• paralelnƒõ
        self.logger.info(f"‚¨áÔ∏è Stahuji {len(download_tasks)} nahr√°vek paralelnƒõ")
        download_results = await asyncio.gather(*download_tasks, return_exceptions=True)
        
        # Krok 3: Zpracuj v√Ωsledky a sma≈æ √∫spƒõ≈°n√© ze Spinoco
        successful_deletions = []
        for i, result in enumerate(download_results):
            if isinstance(result, Exception):
                self.logger.error(f"‚ùå Chyba p≈ôi stahov√°n√≠: {result}")
                self.stats["errors"] += 1
            else:
                call, recording, success = result
                if success:
                    self.stats["recordings_downloaded"] += 1
                    successful_deletions.append((call, recording))
                else:
                    self.stats["errors"] += 1
        
        # Krok 4: Sma≈æ √∫spƒõ≈°nƒõ sta≈æen√© nahr√°vky ze Spinoco
        if successful_deletions:
            self.logger.info(f"üóëÔ∏è Ma≈æu {len(successful_deletions)} nahr√°vek ze Spinoco")
            await self.delete_recordings_from_spinoco(
                successful_deletions, spinoco_client
            )
        
        self.logger.info("‚úÖ Batch processing dokonƒçen")
    
    async def download_single_recording(
        self,
        call: CallTask,
        recording: CallRecording,
        spinoco_client: SpinocoClient,
        sharepoint_client: SharePointClient,
        semaphore: asyncio.Semaphore
    ) -> tuple[CallTask, CallRecording, bool]:
        """
        St√°hne jednu nahr√°vku ze Spinoco na SharePoint a zkontroluje velikost.
        
        Returns:
            tuple: (call, recording, success)
        """
        async with semaphore:
            try:
                # Vygeneruj n√°zev souboru podle metadat (max 15 slov)
                filename = self.generate_filename_from_metadata(call, recording)
                
                # Urƒç√≠ slo≈æku podle mƒõs√≠ce
                folder_path = self.get_month_folder_path(call)
                
                self.logger.info(
                    f"‚¨áÔ∏è Stahuji nahr√°vku {recording.id}",
                    call_id=call.id,
                    filename=filename,
                    folder=folder_path
                )
                
                # St√°hni nahr√°vku ze Spinoco
                recording_data = await spinoco_client.download_recording(call.id, recording.id)
                original_size = len(recording_data)
                
                # Nahraj na SharePoint
                file_info = await sharepoint_client.upload_file(
                    file_content=recording_data,
                    filename=filename,
                    folder_path=folder_path,
                    overwrite=False
                )
                
                # Zkontroluj velikost
                uploaded_size = file_info.get("size", 0)
                if uploaded_size != original_size:
                    self.logger.error(
                        f"‚ùå Velikost se neshoduje: {original_size} != {uploaded_size}",
                        filename=filename
                    )
                    return call, recording, False
                
                self.logger.info(
                    f"‚úÖ Nahr√°vka √∫spƒõ≈°nƒõ nahr√°na a zkontrolov√°na",
                    filename=filename,
                    size_mb=round(original_size / 1024 / 1024, 2)
                )
                
                return call, recording, True
                
            except Exception as e:
                self.logger.error(
                    f"‚ùå Chyba p≈ôi stahov√°n√≠ nahr√°vky",
                    call_id=call.id,
                    recording_id=recording.id,
                    error=str(e)
                )
                return call, recording, False
    
    async def delete_recordings_from_spinoco(
        self,
        successful_deletions: List[tuple[CallTask, CallRecording]],
        spinoco_client: SpinocoClient
    ):
        """Sma≈æe √∫spƒõ≈°nƒõ sta≈æen√© nahr√°vky ze Spinoco."""
        
        delete_tasks = []
        for call, recording in successful_deletions:
            delete_task = spinoco_client.delete_recording(call.id, recording.id)
            delete_tasks.append(delete_task)
        
        # Sma≈æ paralelnƒõ
        delete_results = await asyncio.gather(*delete_tasks, return_exceptions=True)
        
        # Zpracuj v√Ωsledky
        for i, result in enumerate(delete_results):
            call, recording = successful_deletions[i]
            if isinstance(result, Exception):
                self.logger.error(
                    f"‚ùå Nepoda≈ôilo se smazat nahr√°vku ze Spinoco",
                    call_id=call.id,
                    recording_id=recording.id,
                    error=str(result)
                )
                self.stats["errors"] += 1
            else:
                self.stats["recordings_deleted"] += 1
                self.logger.debug(
                    f"üóëÔ∏è Nahr√°vka smaz√°na ze Spinoco",
                    call_id=call.id,
                    recording_id=recording.id
                )
    
    def generate_filename_from_metadata(self, call: CallTask, recording: CallRecording) -> str:
        """
        Vygeneruje n√°zev souboru z metadat hovoru (max 15 slov).
        
        Form√°t: YYYYMMDD_HHMMSS_caller_callee.ogg
        """
        try:
            # Datum z lastUpdate
            call_time = datetime.fromtimestamp(call.lastUpdate / 1000)
            date_str = call_time.strftime("%Y%m%d_%H%M%S")
            
            # Telefonn√≠ ƒç√≠sla (zkr√°cen√©)
            caller, callee = self.extract_phone_numbers(call)
            caller_short = caller[-6:] if caller else "unknown"
            callee_short = callee[-6:] if callee else "unknown" 
            
            # Sestavit n√°zev (max 15 slov = cca 60 znak≈Ø)
            filename = f"{date_str}_{caller_short}_{callee_short}_{recording.id[:8]}.ogg"
            
            # O≈ô√≠zni na rozumnou d√©lku
            if len(filename) > 60:
                filename = f"{date_str}_{recording.id[:8]}.ogg"
            
            return filename
            
        except Exception as e:
            self.logger.warning(f"Chyba p≈ôi generov√°n√≠ n√°zvu souboru: {e}")
            # Fallback
            return f"{call.id}_{recording.id}.ogg"
    
    def get_month_folder_path(self, call: CallTask) -> str:
        """Vr√°t√≠ cestu ke slo≈æce podle mƒõs√≠ce z lastUpdate."""
        try:
            call_time = datetime.fromtimestamp(call.lastUpdate / 1000)
            month_folder = call_time.strftime("%Y/%m")
            
            # Kombinuj s base folder path
            if settings.sharepoint_folder_path:
                return f"{settings.sharepoint_folder_path.strip('/')}/{month_folder}"
            else:
                return month_folder
                
        except Exception as e:
            self.logger.warning(f"Chyba p≈ôi urƒçov√°n√≠ slo≈æky: {e}")
            return settings.sharepoint_folder_path or "recordings"
    
    def extract_phone_numbers(self, call: CallTask) -> tuple[str, str]:
        """Extrahuje telefonn√≠ ƒç√≠sla z call task."""
        try:
            direction = call.tpe.get("direction", {})
            direction_type = direction.get("__tpe")
            
            if direction_type == "Terminating":
                # P≈ô√≠choz√≠ hovor
                caller = direction.get("from", {}).get("number", {}).get("e164", "")
                callee = direction.get("toPhoneNumber", "")
            elif direction_type == "Originating":
                # Odchoz√≠ hovor
                caller = direction.get("fromPhoneNumber", "")
                callee = direction.get("to", {}).get("number", {}).get("e164", "")
            else:
                return "", ""
            
            return caller.lstrip('+'), callee.lstrip('+')
            
        except Exception:
            return "", ""
    
    def log_final_stats(self):
        """Vyp√≠≈°e fin√°ln√≠ statistiky."""
        duration = datetime.now() - self.stats["start_time"]
        
        self.logger.info(
            "üìä Fin√°ln√≠ statistiky stahov√°n√≠",
            duration=str(duration),
            calls_found=self.stats["calls_found"],
            recordings_found=self.stats["recordings_found"],
            recordings_downloaded=self.stats["recordings_downloaded"],
            recordings_deleted=self.stats["recordings_deleted"],
            errors=self.stats["errors"]
        )
        
        if self.stats["errors"] > 0:
            self.logger.warning(f"‚ö†Ô∏è Dokonƒçeno s {self.stats['errors']} chybami")
        else:
            self.logger.info("üéâ V≈°echny nahr√°vky √∫spƒõ≈°nƒõ zpracov√°ny!")


async def main():
    """Hlavn√≠ entry point aplikace."""
    try:
        downloader = SpinocoRecordingDownloader()
        await downloader.run()
        return 0
    except Exception as e:
        print(f"‚ùå Kritick√° chyba: {e}")
        return 1


if __name__ == "__main__":
    sys.exit(asyncio.run(main()))
