#!/usr/bin/env python3
"""
tools/smoke5.py - One-shot smoke test na 5 nahr√°vek

Sekvenƒçnƒõ spust√≠:
1) steps/01_ingest_spinoco/run.py (limit=5, incr)
2) steps/02_transcribe_asr_adapter/run.py (nad v√Ωstupem z 01)

Bez Prefectu, bez dal≈°√≠ch parametr≈Ø. "Spus≈• a sleduj".
"""

import argparse
import json
import subprocess
import sys
import os
from pathlib import Path
from typing import Dict, Any, Optional
import time

# Pou≈æijeme python z aktu√°ln√≠ho venv
REPO = Path(__file__).resolve().parents[1]
PY = sys.executable  # ‚Üê tohle je python z aktu√°ln√≠ho venv!

INGEST = REPO / "steps" / "ingest_spinoco" / "run.py"
TRANS = REPO / "steps" / "transcribe_asr_adapter" / "run.py"


class Colors:
    """Barevn√Ω v√Ωstup pro lep≈°√≠ ƒçitelnost."""
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    MAGENTA = '\033[95m'
    CYAN = '\033[96m'
    WHITE = '\033[97m'
    BOLD = '\033[1m'
    END = '\033[0m'


def print_colored(message: str, color: str = Colors.WHITE, bold: bool = False):
    """Vytiskne barevnou zpr√°vu."""
    prefix = Colors.BOLD if bold else ""
    print(f"{prefix}{color}{message}{Colors.END}")


def print_header(title: str):
    """Vytiskne hlaviƒçku sekce."""
    print_colored(f"\n{'='*60}", Colors.CYAN, bold=True)
    print_colored(f" {title}", Colors.CYAN, bold=True)
    print_colored(f"{'='*60}", Colors.CYAN, bold=True)


def print_step(step: str, status: str = "RUNNING"):
    """Vytiskne stav kroku."""
    status_color = Colors.YELLOW if status == "RUNNING" else Colors.GREEN if status == "SUCCESS" else Colors.RED
    print_colored(f"\nüîß {step} [{status}]", status_color, bold=True)


def check_config_exists(config_path: Path) -> bool:
    """Zkontroluje existenci konfiguraƒçn√≠ho souboru."""
    if not config_path.exists():
        print_colored(f"‚ùå Chyb√≠ konfiguraƒçn√≠ soubor: {config_path}", Colors.RED, bold=True)
        print_colored(f"   Zkop√≠ruj {config_path.with_suffix('.example.yaml')} a vypl≈à token", Colors.YELLOW)
        return False
    return True


def run_step(title: str, args: list[str], cwd: Optional[Path] = None) -> subprocess.CompletedProcess:
    """
    Spust√≠ krok pipeline a vr√°t√≠ v√Ωsledek.
    
    Args:
        title: N√°zev kroku pro v√Ωpis
        args: Argumenty pro python script (bez 'python')
        cwd: Pracovn√≠ adres√°≈ô
        
    Returns:
        CompletedProcess: V√Ωsledek spu≈°tƒõn√≠
    """
    print_step(title, "RUNNING")
    
    # Pou≈æijeme python z venv a zdƒõd√≠me environment
    env = os.environ.copy()  # zdƒõd√≠ VIRTUAL_ENV, PATH, atd.
    cmd = [PY] + [str(a) for a in args]  # ‚Üê spou≈°t√≠me p≈ôes venv python
    
    print_colored(f"P≈ô√≠kaz: {' '.join(cmd)}", Colors.BLUE)
    
    start_time = time.time()
    
    try:
        result = subprocess.run(
            cmd,
            cwd=str(cwd or REPO),
            env=env,
            capture_output=True,
            text=True,
            check=False
        )
        
        duration = time.time() - start_time
        
        # Vytiskni v√Ωstup
        if result.stdout:
            print_colored("STDOUT:", Colors.GREEN)
            print(result.stdout)
        
        if result.stderr:
            print_colored("STDERR:", Colors.RED)
            print(result.stderr)
        
        # Urƒçi status
        if result.returncode == 0:
            print_step(title, "SUCCESS")
            print_colored(f"‚úÖ Dokonƒçeno za {duration:.1f}s", Colors.GREEN)
        else:
            print_step(title, "FAILED")
            print_colored(f"‚ùå Selhalo s k√≥dem {result.returncode} za {duration:.1f}s", Colors.RED)
        
        return result
        
    except Exception as e:
        print_step(title, "ERROR")
        print_colored(f"‚ùå Chyba p≈ôi spu≈°tƒõn√≠: {e}", Colors.RED)
        return subprocess.CompletedProcess(cmd, 1, "", str(e))


def find_latest_run(step_dir: Path) -> Optional[Path]:
    """
    Najde nejnovƒõj≈°√≠ run v adres√°≈ôi kroku.
    
    Args:
        step_dir: Adres√°≈ô kroku (nap≈ô. steps/01_ingest_spinoco/output/runs)
        
    Returns:
        Path: Cesta k nejnovƒõj≈°√≠mu runu nebo None
    """
    runs_dir = step_dir / "output" / "runs"
    
    if not runs_dir.exists():
        return None
    
    # Najdi v≈°echny adres√°≈ôe s ULID n√°zvy
    run_dirs = [d for d in runs_dir.iterdir() if d.is_dir()]
    
    if not run_dirs:
        return None
    
    # Se≈ôaƒè lexikograficky (ULID se ≈ôad√≠ spr√°vnƒõ podle ƒçasu)
    latest_run = max(run_dirs, key=lambda x: x.name)
    
    # Ovƒõ≈ô ≈æe m√° manifest.json
    manifest_path = latest_run / "manifest.json"
    if not manifest_path.exists():
        return None
    
    return latest_run


def read_metrics(path: Path) -> Dict[str, Any]:
    """
    Naƒçte metriky z JSON souboru.
    
    Args:
        path: Cesta k metrics.json
        
    Returns:
        Dict: Metriky nebo pr√°zdn√Ω dict
    """
    if not path.exists():
        return {}
    
    try:
        with open(path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except Exception as e:
        print_colored(f"‚ö†Ô∏è Chyba p≈ôi ƒçten√≠ metrik z {path}: {e}", Colors.YELLOW)
        return {}


def read_manifest(path: Path) -> Dict[str, Any]:
    """
    Naƒçte manifest z JSON souboru.
    
    Args:
        path: Cesta k manifest.json
        
    Returns:
        Dict: Manifest nebo pr√°zdn√Ω dict
    """
    if not path.exists():
        return {}
    
    try:
        with open(path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except Exception as e:
        print_colored(f"‚ö†Ô∏è Chyba p≈ôi ƒçten√≠ manifestu z {path}: {e}", Colors.YELLOW)
        return {}


def main():
    """Hlavn√≠ funkce smoke testu."""
    parser = argparse.ArgumentParser(description="Smoke test na 5 nahr√°vek")
    parser.add_argument('--limit', type=int, default=5, help='Poƒçet nahr√°vek k testov√°n√≠ (default: 5)')
    args = parser.parse_args()
    
    print_header("SMOKE TEST - 5 NAHR√ÅVEK")
    print_colored(f"Limit: {args.limit} nahr√°vek", Colors.CYAN)
    
    # Zkontroluj konfigurace
    print_header("KONTROLA KONFIGURAC√ç")
    
    ingest_config = Path("steps/ingest_spinoco/input/config.yaml")
    transcribe_config = Path("steps/transcribe_asr_adapter/input/config.yaml")
    
    if not check_config_exists(ingest_config):
        return 1
    
    if not check_config_exists(transcribe_config):
        return 1
    
    print_colored("‚úÖ V≈°echny konfigurace existuj√≠", Colors.GREEN)
    
    # Krok 1: Ingest
    print_header("KROK 1: INGEST SPINOCO")
    
    ingest_args = [
        INGEST,
        "--mode", "backfill",
        "--limit", str(args.limit),
        "--max-retry", "2",
        "--config", REPO / "steps/ingest_spinoco/input/config.yaml"
    ]
    
    ingest_result = run_step("INGEST", ingest_args)
    
    if ingest_result.returncode != 0:
        print_colored("‚ùå Ingest selhal - ukonƒçuji", Colors.RED, bold=True)
        return 1
    
    # Najdi nejnovƒõj≈°√≠ ingest run
    print_header("HLED√ÅN√ç NEJNOVƒöJ≈†√çHO INGEST RUN")
    
    ingest_run = find_latest_run(Path("steps/ingest_spinoco"))
    
    if not ingest_run:
        print_colored("‚ùå Nepoda≈ôilo se naj√≠t nejnovƒõj≈°√≠ ingest run", Colors.RED, bold=True)
        return 1
    
    print_colored(f"‚úÖ Nalezen ingest run: {ingest_run.name}", Colors.GREEN)
    
    # Ovƒõ≈ô ≈æe m√° audio soubory
    audio_dir = ingest_run / "data" / "audio"
    if not audio_dir.exists():
        print_colored("‚ùå Ingest run nem√° audio adres√°≈ô", Colors.RED, bold=True)
        return 1
    
    audio_files = list(audio_dir.glob("*.ogg"))
    print_colored(f"‚úÖ Nalezeno {len(audio_files)} audio soubor≈Ø", Colors.GREEN)
    
    # Krok 2: Transcribe
    print_header("KROK 2: TRANSCRIBE ASR ADAPTER")
    
    transcribe_args = [
        TRANS,
        "--mode", "incr",
        "--input-run", ingest_run.name,
        "--limit", str(args.limit),
        "--max-retry", "2",
        "--config", REPO / "steps/transcribe_asr_adapter/input/config.yaml"
    ]
    
    transcribe_result = run_step("TRANSCRIBE", transcribe_args)
    
    # Najdi nejnovƒõj≈°√≠ transcribe run
    print_header("HLED√ÅN√ç NEJNOVƒöJ≈†√çHO TRANSCRIBE RUN")
    
    transcribe_run = find_latest_run(Path("steps/transcribe_asr_adapter"))
    
    if not transcribe_run:
        print_colored("‚ùå Nepoda≈ôilo se naj√≠t nejnovƒõj≈°√≠ transcribe run", Colors.RED, bold=True)
        return 1
    
    print_colored(f"‚úÖ Nalezen transcribe run: {transcribe_run.name}", Colors.GREEN)
    
    # Shrnut√≠
    print_header("SHRNUT√ç V√ùSLEDK≈Æ")
    
    # Naƒçti manifesty a metriky
    ingest_manifest = read_manifest(ingest_run / "manifest.json")
    ingest_metrics = read_metrics(ingest_run / "metrics.json")
    
    transcribe_manifest = read_manifest(transcribe_run / "manifest.json")
    transcribe_metrics = read_metrics(transcribe_run / "metrics.json")
    
    # Vytiskni cesty
    print_colored("üìÅ CESTY K SOUBOR≈ÆM:", Colors.CYAN, bold=True)
    print_colored(f"  INGEST manifest:   {ingest_run / 'manifest.json'}", Colors.WHITE)
    print_colored(f"  INGEST metrics:    {ingest_run / 'metrics.json'}", Colors.WHITE)
    print_colored(f"  TRANSCRIBE manifest: {transcribe_run / 'manifest.json'}", Colors.WHITE)
    print_colored(f"  TRANSCRIBE metrics:  {transcribe_run / 'metrics.json'}", Colors.WHITE)
    
    # Vytiskni metriky
    print_colored("\nüìä METRIKY:", Colors.CYAN, bold=True)
    
    # Ingest metriky
    ingest_recordings = ingest_metrics.get('recordings_total', 0)
    ingest_downloaded = ingest_metrics.get('downloaded_ok', 0)
    ingest_failed = ingest_metrics.get('failed', 0)
    
    print_colored(f"  INGEST:", Colors.WHITE)
    print_colored(f"    üì• Recordings total: {ingest_recordings}", Colors.WHITE)
    print_colored(f"    ‚úÖ Downloaded OK:     {ingest_downloaded}", Colors.GREEN)
    print_colored(f"    ‚ùå Failed:            {ingest_failed}", Colors.RED)
    
    # Transcribe metriky
    transcribe_recordings = transcribe_metrics.get('recordings_total', 0)
    transcribe_transcribed = transcribe_metrics.get('transcribed_ok', 0)
    transcribe_failed = transcribe_metrics.get('failed', 0)
    transcribe_calls = transcribe_metrics.get('calls_total', 0)
    
    print_colored(f"  TRANSCRIBE:", Colors.WHITE)
    print_colored(f"    üì• Recordings total: {transcribe_recordings}", Colors.WHITE)
    print_colored(f"    ‚úÖ Transcribed OK:    {transcribe_transcribed}", Colors.GREEN)
    print_colored(f"    ‚ùå Failed:            {transcribe_failed}", Colors.RED)
    print_colored(f"    üìû Calls total:       {transcribe_calls}", Colors.WHITE)
    
    # Zkontroluj v√Ωstupn√≠ soubory
    print_colored("\nüìÑ V√ùSTUPN√ç SOUBORY:", Colors.CYAN, bold=True)
    
    transcripts_recordings = transcribe_run / "data" / "transcripts_recordings.jsonl"
    transcripts_calls = transcribe_run / "data" / "transcripts_calls.jsonl"
    
    if transcripts_recordings.exists():
        print_colored(f"  ‚úÖ transcripts_recordings.jsonl: {transcripts_recordings}", Colors.GREEN)
    else:
        print_colored(f"  ‚ùå transcripts_recordings.jsonl: CHYB√ç", Colors.RED)
    
    if transcripts_calls.exists():
        print_colored(f"  ‚úÖ transcripts_calls.jsonl: {transcripts_calls}", Colors.GREEN)
    else:
        print_colored(f"  ‚ùå transcripts_calls.jsonl: CHYB√ç", Colors.RED)
    
    # Urƒçi fin√°ln√≠ status
    print_header("FIN√ÅLN√ç STATUS")
    
    if transcribe_result.returncode == 0:
        print_colored("üéâ SMOKE TEST √öSPƒö≈†N√ù!", Colors.GREEN, bold=True)
        print_colored(f"\nüí° Prohl√©dni si v√Ωsledky:", Colors.CYAN)
        print_colored(f"   üìñ Otev≈ôi: {transcripts_calls}", Colors.YELLOW)
        return 0
    else:
        # Zkontroluj jestli je to partial success
        error_json = transcribe_run / "error.json"
        if error_json.exists():
            print_colored("‚ö†Ô∏è SMOKE TEST ƒå√ÅSTEƒåNƒö √öSPƒö≈†N√ù (partial success)", Colors.YELLOW, bold=True)
            print_colored(f"   üìñ Otev≈ôi: {transcripts_calls}", Colors.YELLOW)
            return 0
        else:
            print_colored("‚ùå SMOKE TEST SELHAL", Colors.RED, bold=True)
            return 1


if __name__ == "__main__":
    sys.exit(main())
